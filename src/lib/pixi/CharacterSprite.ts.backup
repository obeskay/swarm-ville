import * as PIXI from "pixi.js";
import gsap from "gsap";
import { Position } from "../types";
import { ObjectPool } from "./ObjectPool";
import { CharacterTextureLoader } from "./CharacterTextureLoader";
import characterSpriteSheetData from "./CharacterSpriteSheetData";

const TILE_SIZE = 32;
const SPRITE_SIZE = 64; // Each frame is 64x64
const SPRITE_SCALE = 2.0; // 2x size (128x128) for better visibility

/**
 * Pool de Graphics para reutilizar círculos de proximidad
 * Evita crear/destruir Graphics constantemente
 */
const graphicsPool = new ObjectPool<PIXI.Graphics>(
  () => new PIXI.Graphics(),
  (graphics) => {
    graphics.clear();
    graphics.visible = true;
    graphics.alpha = 1;
  },
  20, // Max 20 proximity indicators
);

export enum Direction {
  DOWN = 0,
  LEFT = 1,
  RIGHT = 2,
  UP = 0, // Reuse DOWN for UP since we only have 3 rows
}

/**
 * Character sprite with animations
 * Spritesheet format: 192x192 pixels (3x3 grid)
 * - Each frame: 64x64 pixels
 * - Row 0: DOWN facing (3 animation frames)
 * - Row 1: LEFT facing (3 animation frames)
 * - Row 2: RIGHT facing (3 animation frames)
 * - UP direction reuses DOWN frames (mirrored behavior)
 */
export class CharacterSprite extends PIXI.Container {
  private sprite: PIXI.AnimatedSprite;
  private nameText: PIXI.Text;
  private spritesheet: PIXI.Spritesheet | null = null;
  private proximityIndicator: PIXI.Graphics;

  // Grid position for pathfinding (integer)
  public gridPosition: Position;

  // Pixel position for smooth rendering (float)
  public pixelPosition: { x: number; y: number };

  // Movement state
  private targetPixelPosition: { x: number; y: number } | null = null;
  private movementSpeed: number = 6; // pixels per frame at 60fps
  private currentDirection: Direction = Direction.DOWN;
  private currentFrame: number = 0;
  private animationTimer: number = 0;
  private animationSpeed: number = 0.15; // Frames per tick

  // Interaction
  public agentId?: string;

  constructor(
    gridPosition: Position,
    characterId: number,
    name: string,
    interactive: boolean = false,
    agentId?: string,
  ) {
    super();
    this.gridPosition = gridPosition;
    this.agentId = agentId;
    // CRITICAL: Set proper event mode for interactivity
    this.eventMode = interactive ? "dynamic" : "passive";
    this.interactiveChildren = false;
    this.sortableChildren = true;
    this.cursor = interactive ? "pointer" : "default";
    // Use Rectangle for hit area (more reliable than Circle)
    this.hitArea = new PIXI.Rectangle(
      -TILE_SIZE / 2,
      -TILE_SIZE / 2,
      TILE_SIZE,
      TILE_SIZE,
    );

    // Initialize pixel position from grid
    this.pixelPosition = this.gridToPixel(gridPosition);

    // Load character sprite sheet from preloaded cache
    // Clamp characterId to valid range (1-83)
    const clampedId = Math.max(1, Math.min(83, characterId));

    // Get preloaded texture from CharacterTextureLoader
    let texture = CharacterTextureLoader.getCharacterTexture(clampedId);

    if (!texture) {
      console.warn(
        `[CharacterSprite] Character ${clampedId} not found in preloaded cache, using fallback`,
      );
      // Use fallback (Character_001)
      texture = CharacterTextureLoader.getFallbackTexture();

      if (!texture) {
        console.error(
          `[CharacterSprite] Fallback texture also not available, using EMPTY texture`,
        );
        this.baseTexture = PIXI.Texture.EMPTY;
      } else {
        this.baseTexture = texture;
      }
    } else {
      this.baseTexture = texture;
    }

    // Create sprite with loaded texture
    // IMPORTANT: Start with the correct frame immediately (idle frame, direction DOWN, frame 1)
    console.log("[CharacterSprite] About to create sprite, baseTexture:", {
      width: this.baseTexture.width,
      height: this.baseTexture.height,
      valid: this.baseTexture.valid,
      source: !!this.baseTexture.source,
    });

    // TEST: Use base texture directly to verify rendering works
    this.sprite = new PIXI.Sprite(this.baseTexture);
    this.sprite.anchor.set(0.5, 1); // Bottom-center anchor
    this.sprite.scale.set(SPRITE_SCALE * 0.33); // Scale down since using full 192x192

    console.log("[CharacterSprite] Sprite created with BASE texture (TEST):", {
      textureWidth: this.sprite.texture.width,
      textureHeight: this.sprite.texture.height,
      visible: this.sprite.visible,
      alpha: this.sprite.alpha,
      tint: this.sprite.tint,
      scaleX: this.sprite.scale.x,
      scaleY: this.sprite.scale.y,
    });

    // Create name label
    this.nameText = new PIXI.Text({
      text: name,
      style: {
        fontSize: 10,
        fill: 0xffffff,
        align: "center",
        fontWeight: "bold",
        stroke: { color: 0x000000, width: 2 },
      },
    });
    this.nameText.anchor.set(0.5);
    this.nameText.y = -TILE_SIZE - 8;

    // Obtener proximity indicator del pool
    this.proximityIndicator = graphicsPool.acquire();
    this.proximityIndicator.circle(0, 0, TILE_SIZE / 2 + 4);
    this.proximityIndicator.stroke({ color: 0x10b981, width: 2, alpha: 0.6 });
    this.proximityIndicator.visible = false;
    this.proximityIndicator.zIndex = -1; // Behind the sprite

    this.addChild(this.proximityIndicator);
    this.addChild(this.sprite);
    this.addChild(this.nameText);

    // Set world position
    this.position.set(this.pixelPosition.x, this.pixelPosition.y);
    this.zIndex = this.pixelPosition.y;

    // Enable interaction with GSAP-powered smooth microinteractions
    if (interactive && agentId) {
      let isHovered = false;
      let isDragging = false;
      let dragStartX = 0;
      let dragStartY = 0;

      // ✨ Hover: Smooth scale + glow with GSAP
      this.on("pointerover", () => {
        isHovered = true;

        // Kill any running animations to avoid conflicts
        gsap.killTweensOf([this.sprite.scale, this.nameText]);

        // Smooth hover animation
        gsap.to(this.sprite.scale, {
          x: SPRITE_SCALE * 1.15,
          y: SPRITE_SCALE * 1.15,
          duration: 0.2,
          ease: "back.out",
        });

        // Name text pop animation
        gsap.to(this.nameText, {
          scaleX: 1.1,
          scaleY: 1.1,
          duration: 0.2,
          ease: "elastic.out",
        });

        // Show proximity indicator with fade in
        this.proximityIndicator.visible = true;
        this.proximityIndicator.clear();
        this.proximityIndicator.circle(0, 0, TILE_SIZE / 2 + 6);
        this.proximityIndicator.stroke({
          color: 0x60a5fa,
          width: 3,
          alpha: 0,
        });

        gsap.to(this.proximityIndicator.stroke, {
          alpha: 0.8,
          duration: 0.15,
        });

        // Color tint animation
        this.nameText.style.fill = 0x60a5fa;
      });

      // ✨ Unhover: Smooth reset
      this.on("pointerout", () => {
        isHovered = false;

        gsap.killTweensOf([this.sprite.scale, this.nameText, this.sprite]);

        // Smooth scale back
        gsap.to(this.sprite.scale, {
          x: SPRITE_SCALE,
          y: SPRITE_SCALE,
          duration: 0.2,
          ease: "back.out",
        });

        // Name text scale back
        gsap.to(this.nameText, {
          scaleX: 1,
          scaleY: 1,
          duration: 0.2,
          ease: "back.out",
        });

        // Skew reset
        gsap.to(this.sprite, {
          skewX: 0,
          duration: 0.15,
        });

        // Indicator fade out
        gsap.to(this.proximityIndicator.stroke, {
          alpha: 0,
          duration: 0.15,
          onComplete: () => {
            this.proximityIndicator.visible = false;
          },
        });

        // Color reset
        this.nameText.style.fill = 0xffffff;
      });

      // ✨ Click: Bounce + squeeze effect with GSAP
      this.on("pointerdown", (event) => {
        // Prevent default and setup drag
        dragStartX = event.global.x;
        dragStartY = event.global.y;

        gsap.killTweensOf(this.sprite.scale);

        // Squeeze animation on click
        gsap.to(this.sprite.scale, {
          x: SPRITE_SCALE * 0.8,
          y: SPRITE_SCALE * 1.1,
          duration: 0.1,
          ease: "power2.in",
        });

        // Spring back animation
        gsap.to(this.sprite.scale, {
          x: SPRITE_SCALE * (isHovered ? 1.15 : 1),
          y: SPRITE_SCALE * (isHovered ? 1.15 : 1),
          duration: 0.3,
          delay: 0.1,
          ease: "elastic.out",
        });

        // Bounce effect with slight rotation
        gsap.to(this.sprite, {
          rotation: 0.05,
          duration: 0.1,
          yoyo: true,
          repeat: 1,
        });

        this.onInteract();
      });

      // ✨ Hover move: Subtle tilt effect
      this.on("pointermove", (event) => {
        if (isHovered && !isDragging) {
          // Calculate tilt based on mouse position relative to sprite
          const rect = this.getBounds();
          const centerX = rect.x + rect.width / 2;
          const relativeX = event.global.x - centerX;
          const tilt = Math.max(-0.1, Math.min(0.1, relativeX / 100));

          gsap.to(this.sprite, {
            skewX: tilt,
            duration: 0.15,
            ease: "power2.out",
          });
        }
      });

      // ✨ Drag and drop support
      this.on("pointerdown", () => {
        isDragging = true;
        gsap.to(this, {
          alpha: 0.8,
          duration: 0.1,
        });
      });

      this.on("pointermove", (event) => {
        if (isDragging && this.parent) {
          // Update position while dragging
          const newX = event.global.x - this.parent.x;
          const newY = event.global.y - this.parent.y;

          gsap.to(this, {
            x: newX,
            y: newY,
            duration: 0,
          });
        }
      });

      this.on("pointerup", () => {
        if (isDragging) {
          isDragging = false;
          gsap.to(this, {
            alpha: 1,
            duration: 0.2,
            ease: "back.out",
          });
        }
      });

      // Touch support for mobile
      this.on("touchstart", () => {
        isHovered = true;
        gsap.to(this.sprite.scale, {
          x: SPRITE_SCALE * 1.2,
          y: SPRITE_SCALE * 1.2,
          duration: 0.15,
          ease: "back.out",
        });
      });

      this.on("touchend", () => {
        isHovered = false;
        gsap.to(this.sprite.scale, {
          x: SPRITE_SCALE,
          y: SPRITE_SCALE,
          duration: 0.2,
          ease: "back.out",
        });
      });
    }
  }

  private getFrameTexture(direction: Direction, frame: number): PIXI.Texture {
    // Spritesheet layout: 192x192 (3x3 grid of 64x64 frames)
    // Row 0 (DOWN), Row 1 (LEFT), Row 2 (RIGHT)
    // Each row has 3 animation frames

    // Clamp to valid ranges
    const clampedFrame = Math.min(2, Math.max(0, frame)); // 0-2
    const clampedDirection = Math.min(2, Math.max(0, direction)); // 0-2

    const x = clampedFrame * SPRITE_SIZE;
    const y = clampedDirection * SPRITE_SIZE;

    // Safety check for texture source
    if (!this.baseTexture || !this.baseTexture.source) {
      console.warn(
        "[CharacterSprite] Base texture not ready, returning empty texture",
      );
      return PIXI.Texture.EMPTY;
    }

    // DEBUG: Frame extraction (currently not used in TEST mode)
    // console.log("[CharacterSprite] Creating frame texture:", {
    //   direction, frame, x, y, SPRITE_SIZE,
    //   baseTextureWidth: this.baseTexture.width,
    //   baseTextureHeight: this.baseTexture.height,
    //   sourceValid: !!this.baseTexture.source,
    // });

    // Create a new texture from the base texture with a specific frame
    // PixiJS v8 approach: clone the texture and update the frame
    const frameTexture = this.baseTexture.clone();
    frameTexture.frame = new PIXI.Rectangle(x, y, SPRITE_SIZE, SPRITE_SIZE);
    frameTexture.updateUvs();

    // console.log("[CharacterSprite] Frame texture created:", {
    //   width: frameTexture.width,
    //   height: frameTexture.height,
    //   valid: frameTexture.valid,
    // });

    return frameTexture;
  }

  private gridToPixel(gridPos: Position): { x: number; y: number } {
    return {
      x: gridPos.x * TILE_SIZE,
      y: gridPos.y * TILE_SIZE,
    };
  }

  private updateDirection(): void {
    if (!this.targetPixelPosition) return;

    const dx = this.targetPixelPosition.x - this.pixelPosition.x;
    const dy = this.targetPixelPosition.y - this.pixelPosition.y;

    // Determine primary direction based on larger delta
    if (Math.abs(dx) > Math.abs(dy)) {
      this.currentDirection = dx > 0 ? Direction.RIGHT : Direction.LEFT;
    } else {
      this.currentDirection = dy > 0 ? Direction.DOWN : Direction.UP;
    }
  }

  private updateAnimation(deltaTime: number): void {
    // DISABLED IN TEST MODE - using base texture without frame extraction
    // TODO: Re-enable when frame extraction is fixed
    return;

    // if (!this.targetPixelPosition) {
    //   // Idle - show frame 1 (middle frame)
    //   this.currentFrame = 1;
    //   this.sprite.texture = this.getFrameTexture(
    //     this.currentDirection,
    //     this.currentFrame,
    //   );
    //   return;
    // }

    // // Walking animation
    // this.animationTimer += deltaTime * this.animationSpeed;
    // if (this.animationTimer >= 1) {
    //   this.animationTimer = 0;
    //   this.currentFrame = (this.currentFrame + 1) % 3; // Cycle through 0, 1, 2
    //   this.sprite.texture = this.getFrameTexture(
    //     this.currentDirection,
    //     this.currentFrame,
    //   );
    // }
  }

  /**
   * Update called every frame from game loop
   */
  public update(deltaTime: number): void {
    // Guard: Ensure sprite exists and has scale before updating
    if (!this.sprite || !this.sprite.scale) {
      console.error(
        "[CharacterSprite] update() called but sprite or sprite.scale is null",
      );
      return;
    }

    // Update direction before moving
    this.updateDirection();

    // Update movement
    if (this.targetPixelPosition) {
      const dx = this.targetPixelPosition.x - this.pixelPosition.x;
      const dy = this.targetPixelPosition.y - this.pixelPosition.y;
      const distance = Math.sqrt(dx * dx + dy * dy);

      const actualSpeed = this.movementSpeed * deltaTime;

      if (distance < actualSpeed) {
        // Snap to target
        this.pixelPosition.x = this.targetPixelPosition.x;
        this.pixelPosition.y = this.targetPixelPosition.y;
        this.targetPixelPosition = null;

        // ✨ Reset squash/stretch when stopped
        this.sprite.scale.set(SPRITE_SCALE, SPRITE_SCALE);
      } else {
        // Move toward target
        const ratio = actualSpeed / distance;
        this.pixelPosition.x += dx * ratio;
        this.pixelPosition.y += dy * ratio;

        // ✨ Squash/stretch effect during movement (simple juice)
        // Slightly stretch in movement direction, squash perpendicular
        const stretchAmount = 0.08; // Subtle effect
        if (
          this.currentDirection === Direction.LEFT ||
          this.currentDirection === Direction.RIGHT
        ) {
          // Horizontal movement: stretch horizontally, squash vertically
          this.sprite.scale.set(
            SPRITE_SCALE * (1 + stretchAmount),
            SPRITE_SCALE * (1 - stretchAmount * 0.5),
          );
        } else {
          // Vertical movement: squash horizontally, stretch vertically
          this.sprite.scale.set(
            SPRITE_SCALE * (1 - stretchAmount * 0.5),
            SPRITE_SCALE * (1 + stretchAmount),
          );
        }
      }

      // Update sprite position and depth
      this.position.set(this.pixelPosition.x, this.pixelPosition.y);
      this.zIndex = this.pixelPosition.y;
    } else {
      // ✨ Ensure scale is reset when idle
      this.sprite.scale.set(SPRITE_SCALE, SPRITE_SCALE);
    }

    // Update animation
    this.updateAnimation(deltaTime);
  }

  /**
   * Set target grid position for movement
   */
  public setTargetGridPosition(gridPos: Position): void {
    this.gridPosition = gridPos;
    this.targetPixelPosition = this.gridToPixel(gridPos);
  }

  /**
   * Instantly teleport to grid position
   */
  public teleportToGridPosition(gridPos: Position): void {
    this.gridPosition = gridPos;
    this.pixelPosition = this.gridToPixel(gridPos);
    this.targetPixelPosition = null;
    this.position.set(this.pixelPosition.x, this.pixelPosition.y);
    this.zIndex = this.pixelPosition.y;
  }

  /**
   * Check if currently moving
   */
  public isMoving(): boolean {
    return this.targetPixelPosition !== null;
  }

  /**
   * Get distance to target in pixels
   */
  public getDistanceToTarget(): number {
    if (!this.targetPixelPosition) return 0;

    const dx = this.targetPixelPosition.x - this.pixelPosition.x;
    const dy = this.targetPixelPosition.y - this.pixelPosition.y;
    return Math.sqrt(dx * dx + dy * dy);
  }

  /**
   * Get current pixel position
   */
  public getPixelPosition(): { x: number; y: number } {
    return { ...this.pixelPosition };
  }

  /**
   * Handle interaction (click on agent)
   */
  private onInteract(): void {
    if (this.agentId) {
      // Dispatch custom event for agent interaction
      const event = new CustomEvent("agent-interact", {
        detail: { agentId: this.agentId },
        bubbles: true,
      });
      window.dispatchEvent(event);
    }
  }

  /**
   * Set character sprite (change appearance)
   */
  public setCharacter(characterId: number): void {
    // Clamp characterId to valid range (1-83)
    const clampedId = Math.max(1, Math.min(83, characterId));

    // Get preloaded texture from CharacterTextureLoader
    let texture = CharacterTextureLoader.getCharacterTexture(clampedId);

    if (!texture) {
      console.warn(
        `[CharacterSprite] Character ${clampedId} not found in preloaded cache, using fallback`,
      );
      // Use fallback (Character_001)
      texture = CharacterTextureLoader.getFallbackTexture();

      if (!texture) {
        console.error(
          `[CharacterSprite] Fallback texture also not available, using EMPTY texture`,
        );
        this.baseTexture = PIXI.Texture.EMPTY;
      } else {
        this.baseTexture = texture;
      }
    } else {
      this.baseTexture = texture;
    }

    this.sprite.texture = this.getFrameTexture(
      this.currentDirection,
      this.currentFrame,
    );
  }

  /**
   * Update name text
   */
  public setName(name: string): void {
    this.nameText.text = name;
  }

  /**
   * Show or hide proximity indicator
   */
  public setProximityHighlight(visible: boolean): void {
    this.proximityIndicator.visible = visible;
  }

  /**
   * Check if within proximity of another position
   */
  public isInProximity(otherPos: Position, radius: number): boolean {
    const dx = Math.abs(this.gridPosition.x - otherPos.x);
    const dy = Math.abs(this.gridPosition.y - otherPos.y);
    return dx <= radius && dy <= radius;
  }

  /**
   * Destruir sprite y devolver recursos al pool
   */
  public destroy(options?: boolean | PIXI.DestroyOptions): void {
    // Devolver proximity indicator al pool
    if (this.proximityIndicator) {
      graphicsPool.release(this.proximityIndicator);
    }

    super.destroy(options);
  }
}
