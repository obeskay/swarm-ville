import { describe, it, expect } from 'vitest'
import { findPath } from '../../lib/pathfinding'

const gridWidth = 1000
const gridHeight = 1000

describe('Pathfinding - Performance Tests', () => {
  describe('Pathfinding Performance Benchmarks', () => {
    it('should find path for 10 tiles in < 5ms', () => {
      const start = performance.now()
      const path = findPath(
        { x: 0, y: 0 },
        { x: 10, y: 0 },
        new Set()
      )
      const duration = performance.now() - start

      expect(path.length).toBeGreaterThan(0)
      expect(duration).toBeLessThan(5)
    })

    it('should find path for 50 tiles in < 50ms', () => {
      const start = performance.now()
      const path = findPath(
        { x: 0, y: 0 },
        { x: 50, y: 50 },
        new Set()
      )
      const duration = performance.now() - start

      expect(path.length).toBeGreaterThan(0)
      expect(duration).toBeLessThan(50)
    })

    it('should find path for 100 tiles in < 150ms', () => {
      const start = performance.now()
      const path = findPath(
        { x: 0, y: 0 },
        { x: 100, y: 100 },
        new Set()
      )
      const duration = performance.now() - start

      expect(path.length).toBeGreaterThan(0)
      expect(duration).toBeLessThan(150)
    })

    it('should handle obstacle avoidance efficiently', () => {
      const obstacles = new Set<string>()
      // Create wall
      for (let i = 0; i < 50; i++) {
        obstacles.add(`${i},25`)
      }

      const start = performance.now()
      const path = findPath(
        { x: 0, y: 0 },
        { x: 100, y: 100 },
        obstacles
      )
      const duration = performance.now() - start

      expect(path.length).toBeGreaterThan(0)
      expect(duration).toBeLessThan(100)
    })

    it('should handle unreachable goal efficiently', () => {
      const obstacles = new Set<string>()
      // Create complete barrier
      for (let x = 49; x <= 51; x++) {
        for (let y = 0; y < 100; y++) {
          obstacles.add(`${x},${y}`)
        }
      }

      const start = performance.now()
      const path = findPath(
        { x: 0, y: 50 },
        { x: 100, y: 50 },
        obstacles
      )
      const duration = performance.now() - start

      // Should fail quickly without excessive searching
      expect(duration).toBeLessThan(100)
    })

    it('should handle multiple pathfinding requests in parallel', () => {
      const start = performance.now()
      const paths = Array.from({ length: 10 }).map((_, i) => {
        return findPath(
          { x: 0, y: 0 },
          { x: 50 + i * 5, y: 50 + i * 5 },
          new Set()
        )
      })
      const duration = performance.now() - start

      expect(paths).toHaveLength(10)
      expect(paths.every((p) => p.length > 0)).toBe(true)
      expect(duration).toBeLessThan(200) // 10 paths of ~50 tiles each
    })

    it('should maintain consistent performance with repeated calls', () => {
      const durations: number[] = []

      for (let i = 0; i < 100; i++) {
        const start = performance.now()
        findPath(
          { x: 0, y: 0 },
          { x: 25, y: 25 },
          new Set()
        )
        durations.push(performance.now() - start)
      }

      const avg = durations.reduce((a, b) => a + b, 0) / durations.length
      const max = Math.max(...durations)

      // Average should be consistent and low
      expect(avg).toBeLessThan(10)
      // Max should not be significantly higher than average
      expect(max).toBeLessThan(avg * 5)
    })
  })

  describe('Memory Efficiency', () => {
    it('should not create excessive intermediate objects', () => {
      // Measure baseline memory
      const baseline = getMemoryUsage()

      // Run pathfinding
      for (let i = 0; i < 1000; i++) {
        findPath(
          { x: 0, y: 0 },
          { x: 50, y: 50 },
          new Set()
        )
      }

      const after = getMemoryUsage()
      const increase = after - baseline

      // Should not exceed reasonable memory increase
      expect(increase).toBeLessThan(10_000_000) // 10MB
    })
  })

  describe('Edge Cases Performance', () => {
    it('should handle zero-distance path quickly', () => {
      const start = performance.now()
      const path = findPath(
        { x: 25, y: 25 },
        { x: 25, y: 25 },
        new Set()
      )
      const duration = performance.now() - start

      expect(path).toHaveLength(1)
      expect(duration).toBeLessThan(1)
    })

    it('should handle diagonal paths efficiently', () => {
      const start = performance.now()
      const path = findPath(
        { x: 0, y: 0 },
        { x: 100, y: 100 },
        new Set()
      )
      const duration = performance.now() - start

      expect(path.length).toBeGreaterThan(0)
      expect(duration).toBeLessThan(150)
    })
  })
})

function getMemoryUsage(): number {
  if ('memory' in performance) {
    const memory = (performance as any).memory
    return memory.usedJSHeapSize
  }
  return 0
}
